The idea is to introduce a client secret policy part of client policies, similarly to password policies for users. Initially it would not be extensible, but would be just a simple key/value configuration.

We'd have the following options in client secret policy to cover secret rotation:

Secret expiration: [seconds]
Secret rotation enabled: [boolean]
Rotated secret expiration: [seconds]
As these options are part of client policies it will be possible to define different values for different groups of clients.

Some additional options we may want to add in the future includes:

Allow supplying the secret through APIs. If disabled all client secrets will be generated by Keycloak.
Length/complexity of the client secrets if the above is enabled
Enable/disable hashing of secrets, and configuring the hashing algorithm
By default secret rotation would not be enabled, and Keycloak would have the behaviour it currently has. We would add the client secret creation time though.

If secret expiration is enabled a client secret is no longer valid if secret creation time + secret rotation >= current time. We would also return the client_secret_expires_at in OIDC dynamic client registration, as well as the Keycloak Admin APIs.

If secret rotation is enabled the old client secret will be stored as a secondary client secret, and valid until rotated secret expiration, or if explicitly removed. For the latter we would need an endpoint to support removing the secondary client secret.

There will not be a background task that expires the secrets, nor will there be a background task that updates the secret. Expiration of secrets will be done when the client is authenticating, and updating the secrets has to be initiated through client update endpoints (dynamic client registration, or KC admin APIs).

As an example for dynamic client registration:

Secret rotation is enabled, secret expiration is 30 days, rotated secret expiration is 2 days
Client is created through a client registration request with a new generated secret
31 days later the client tries to authenticate, but the authentication is unsuccessful has KC sees the secret has expired
Client is updated through a client update request, which will generate a new secret and return it in the response
Client can now be updated and authentication is successful again
A similar example, but with KC Admin UI

Same settings as above
Client is created
After 25 days the admin logs in to KC Admin UI can generates a new client secret
The admin updates the client secret in the application
The admin can now either log back in to the KC Admin UI and remove the rotated secret, or just leave it as it will be invalid after 2 days
If the admin suspects a leak of the secret the admin should obviously remove the rotated secret
The changes needed in the Admin UI for a client would be:

Show expiration time if applicable
Show secondary secret and expiration time if applicable, and add button to remove secondary secret
This approach allows a global control over client secrets within a realm, and has less changes to the APIs, and is fully backwards compatible as there would be no change to the default behaviour. It also fits better into dynamic client registration than the previous proposal.
